import cv2
import socket
import struct
import pickle
import miniupnpc
import time
import threading

# --- Configuration ---
HOST = "0.0.0.0"
PORT = 9999
ANNOUNCE_IP = "93.28.230.141"
ANNOUNCE_PORT = 5000

# --- UPnP pour récupérer l'IP publique ---
upnp = miniupnpc.UPnP()
upnp.discoverdelay = 200
upnp.discover()
upnp.selectigd()
external_ip = upnp.externalipaddress()
print("Adresse IP publique :", external_ip)

try:
    upnp.addportmapping(PORT, 'TCP', upnp.lanaddr, PORT, 'PythonCamServer', '')
    print(f"Port {PORT} mappé via UPnP")
except Exception as e:
    print("Erreur mapping UPnP:", e)

# --- Socket TCP pour serveur caméra ---
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
server_socket.bind((HOST, PORT))
server_socket.listen(1)
print("Serveur prêt sur le port", PORT)

# --- Socket UDP pour envoyer l'IP publique en continu ---
announce_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# --- Fonction pour envoyer l'IP en boucle ---
def announce_ip():
    while True:
        announce_socket.sendto(external_ip.encode(), (ANNOUNCE_IP, ANNOUNCE_PORT))
        time.sleep(1)  # envoie toutes les 1 seconde

# Lancement du thread pour l'annonce
threading.Thread(target=announce_ip, daemon=True).start()

# --- Webcam ---
cap = cv2.VideoCapture(0)

try:
    while True:
        print("En attente de connexion client...")
        conn, addr = server_socket.accept()
        print("Client connecté:", addr)

        try:
            while cap.isOpened():
                ret, frame = cap.read()
                if not ret:
                    break
                data = pickle.dumps(frame)
                message = struct.pack("Q", len(data)) + data
                conn.sendall(message)
        except Exception as e:
            print("Client déconnecté:", e)
            conn.close()
            continue

except KeyboardInterrupt:
    print("\nArrêt du serveur...")

finally:
    cap.release()
    server_socket.close()
    try:
        upnp.deleteportmapping(PORT, 'TCP')
    except:
        pass
